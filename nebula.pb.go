// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: nebula.proto

package nebula

import (
	fmt "fmt"
	proto "github.com/gogo/protobuf/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type NebulaMeta_MessageType int32

const (
	NebulaMeta_None                      NebulaMeta_MessageType = 0
	NebulaMeta_HostQuery                 NebulaMeta_MessageType = 1
	NebulaMeta_HostQueryReply            NebulaMeta_MessageType = 2
	NebulaMeta_HostUpdateNotification    NebulaMeta_MessageType = 3
	NebulaMeta_HostMovedNotification     NebulaMeta_MessageType = 4
	NebulaMeta_HostPunchNotification     NebulaMeta_MessageType = 5
	NebulaMeta_HostWhoami                NebulaMeta_MessageType = 6
	NebulaMeta_HostWhoamiReply           NebulaMeta_MessageType = 7
	NebulaMeta_PathCheck                 NebulaMeta_MessageType = 8
	NebulaMeta_PathCheckReply            NebulaMeta_MessageType = 9
	NebulaMeta_HostUpdateNotificationAck NebulaMeta_MessageType = 10
)

var NebulaMeta_MessageType_name = map[int32]string{
	0:  "None",
	1:  "HostQuery",
	2:  "HostQueryReply",
	3:  "HostUpdateNotification",
	4:  "HostMovedNotification",
	5:  "HostPunchNotification",
	6:  "HostWhoami",
	7:  "HostWhoamiReply",
	8:  "PathCheck",
	9:  "PathCheckReply",
	10: "HostUpdateNotificationAck",
}

var NebulaMeta_MessageType_value = map[string]int32{
	"None":                      0,
	"HostQuery":                 1,
	"HostQueryReply":            2,
	"HostUpdateNotification":    3,
	"HostMovedNotification":     4,
	"HostPunchNotification":     5,
	"HostWhoami":                6,
	"HostWhoamiReply":           7,
	"PathCheck":                 8,
	"PathCheckReply":            9,
	"HostUpdateNotificationAck": 10,
}

func (x NebulaMeta_MessageType) String() string {
	return proto.EnumName(NebulaMeta_MessageType_name, int32(x))
}

func (NebulaMeta_MessageType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_2d65afa7693df5ef, []int{0, 0}
}

type NebulaPing_MessageType int32

const (
	NebulaPing_Ping  NebulaPing_MessageType = 0
	NebulaPing_Reply NebulaPing_MessageType = 1
)

var NebulaPing_MessageType_name = map[int32]string{
	0: "Ping",
	1: "Reply",
}

var NebulaPing_MessageType_value = map[string]int32{
	"Ping":  0,
	"Reply": 1,
}

func (x NebulaPing_MessageType) String() string {
	return proto.EnumName(NebulaPing_MessageType_name, int32(x))
}

func (NebulaPing_MessageType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_2d65afa7693df5ef, []int{7, 0}
}

type NebulaControl_MessageType int32

const (
	NebulaControl_None                NebulaControl_MessageType = 0
	NebulaControl_CreateRelayRequest  NebulaControl_MessageType = 1
	NebulaControl_CreateRelayResponse NebulaControl_MessageType = 2
)

var NebulaControl_MessageType_name = map[int32]string{
	0: "None",
	1: "CreateRelayRequest",
	2: "CreateRelayResponse",
}

var NebulaControl_MessageType_value = map[string]int32{
	"None":                0,
	"CreateRelayRequest":  1,
	"CreateRelayResponse": 2,
}

func (x NebulaControl_MessageType) String() string {
	return proto.EnumName(NebulaControl_MessageType_name, int32(x))
}

func (NebulaControl_MessageType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_2d65afa7693df5ef, []int{10, 0}
}

type NebulaMeta struct {
	Type    NebulaMeta_MessageType `protobuf:"varint,1,opt,name=Type,proto3,enum=nebula.NebulaMeta_MessageType" json:"Type,omitempty"`
	Details *NebulaMetaDetails     `protobuf:"bytes,2,opt,name=Details,proto3" json:"Details,omitempty"`
}

func (m *NebulaMeta) Reset()         { *m = NebulaMeta{} }
func (m *NebulaMeta) String() string { return proto.CompactTextString(m) }
func (*NebulaMeta) ProtoMessage()    {}
func (*NebulaMeta) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d65afa7693df5ef, []int{0}
}
func (m *NebulaMeta) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NebulaMeta) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NebulaMeta.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NebulaMeta) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NebulaMeta.Merge(m, src)
}
func (m *NebulaMeta) XXX_Size() int {
	return m.Size()
}
func (m *NebulaMeta) XXX_DiscardUnknown() {
	xxx_messageInfo_NebulaMeta.DiscardUnknown(m)
}

var xxx_messageInfo_NebulaMeta proto.InternalMessageInfo

func (m *NebulaMeta) GetType() NebulaMeta_MessageType {
	if m != nil {
		return m.Type
	}
	return NebulaMeta_None
}

func (m *NebulaMeta) GetDetails() *NebulaMetaDetails {
	if m != nil {
		return m.Details
	}
	return nil
}

type NebulaMetaDetails struct {
	OldVpnAddr                  uint32                       `protobuf:"varint,1,opt,name=OldVpnAddr,proto3" json:"OldVpnAddr,omitempty"` // Deprecated: Do not use.
	VpnAddr                     *Addr                        `protobuf:"bytes,6,opt,name=VpnAddr,proto3" json:"VpnAddr,omitempty"`
	OldRelayVpnAddrs            []uint32                     `protobuf:"varint,5,rep,packed,name=OldRelayVpnAddrs,proto3" json:"OldRelayVpnAddrs,omitempty"` // Deprecated: Do not use.
	RelayVpnAddrs               []*Addr                      `protobuf:"bytes,7,rep,name=RelayVpnAddrs,proto3" json:"RelayVpnAddrs,omitempty"`
	HandshakeFilteringWhitelist *HandshakeFilteringWhitelist `protobuf:"bytes,8,opt,name=HandshakeFilteringWhitelist,proto3" json:"HandshakeFilteringWhitelist,omitempty"`
	V4AddrPorts                 []*V4AddrPort                `protobuf:"bytes,2,rep,name=V4AddrPorts,proto3" json:"V4AddrPorts,omitempty"`
	V6AddrPorts                 []*V6AddrPort                `protobuf:"bytes,4,rep,name=V6AddrPorts,proto3" json:"V6AddrPorts,omitempty"`
	Counter                     uint32                       `protobuf:"varint,3,opt,name=counter,proto3" json:"counter,omitempty"`
}

func (m *NebulaMetaDetails) Reset()         { *m = NebulaMetaDetails{} }
func (m *NebulaMetaDetails) String() string { return proto.CompactTextString(m) }
func (*NebulaMetaDetails) ProtoMessage()    {}
func (*NebulaMetaDetails) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d65afa7693df5ef, []int{1}
}
func (m *NebulaMetaDetails) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NebulaMetaDetails) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NebulaMetaDetails.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NebulaMetaDetails) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NebulaMetaDetails.Merge(m, src)
}
func (m *NebulaMetaDetails) XXX_Size() int {
	return m.Size()
}
func (m *NebulaMetaDetails) XXX_DiscardUnknown() {
	xxx_messageInfo_NebulaMetaDetails.DiscardUnknown(m)
}

var xxx_messageInfo_NebulaMetaDetails proto.InternalMessageInfo

// Deprecated: Do not use.
func (m *NebulaMetaDetails) GetOldVpnAddr() uint32 {
	if m != nil {
		return m.OldVpnAddr
	}
	return 0
}

func (m *NebulaMetaDetails) GetVpnAddr() *Addr {
	if m != nil {
		return m.VpnAddr
	}
	return nil
}

// Deprecated: Do not use.
func (m *NebulaMetaDetails) GetOldRelayVpnAddrs() []uint32 {
	if m != nil {
		return m.OldRelayVpnAddrs
	}
	return nil
}

func (m *NebulaMetaDetails) GetRelayVpnAddrs() []*Addr {
	if m != nil {
		return m.RelayVpnAddrs
	}
	return nil
}

func (m *NebulaMetaDetails) GetHandshakeFilteringWhitelist() *HandshakeFilteringWhitelist {
	if m != nil {
		return m.HandshakeFilteringWhitelist
	}
	return nil
}

func (m *NebulaMetaDetails) GetV4AddrPorts() []*V4AddrPort {
	if m != nil {
		return m.V4AddrPorts
	}
	return nil
}

func (m *NebulaMetaDetails) GetV6AddrPorts() []*V6AddrPort {
	if m != nil {
		return m.V6AddrPorts
	}
	return nil
}

func (m *NebulaMetaDetails) GetCounter() uint32 {
	if m != nil {
		return m.Counter
	}
	return 0
}

type Addr struct {
	Hi uint64 `protobuf:"varint,1,opt,name=Hi,proto3" json:"Hi,omitempty"`
	Lo uint64 `protobuf:"varint,2,opt,name=Lo,proto3" json:"Lo,omitempty"`
}

func (m *Addr) Reset()         { *m = Addr{} }
func (m *Addr) String() string { return proto.CompactTextString(m) }
func (*Addr) ProtoMessage()    {}
func (*Addr) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d65afa7693df5ef, []int{2}
}
func (m *Addr) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Addr) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Addr.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Addr) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Addr.Merge(m, src)
}
func (m *Addr) XXX_Size() int {
	return m.Size()
}
func (m *Addr) XXX_DiscardUnknown() {
	xxx_messageInfo_Addr.DiscardUnknown(m)
}

var xxx_messageInfo_Addr proto.InternalMessageInfo

func (m *Addr) GetHi() uint64 {
	if m != nil {
		return m.Hi
	}
	return 0
}

func (m *Addr) GetLo() uint64 {
	if m != nil {
		return m.Lo
	}
	return 0
}

type V4AddrPort struct {
	Addr uint32 `protobuf:"varint,1,opt,name=Addr,proto3" json:"Addr,omitempty"`
	Port uint32 `protobuf:"varint,2,opt,name=Port,proto3" json:"Port,omitempty"`
}

func (m *V4AddrPort) Reset()         { *m = V4AddrPort{} }
func (m *V4AddrPort) String() string { return proto.CompactTextString(m) }
func (*V4AddrPort) ProtoMessage()    {}
func (*V4AddrPort) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d65afa7693df5ef, []int{3}
}
func (m *V4AddrPort) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *V4AddrPort) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_V4AddrPort.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *V4AddrPort) XXX_Merge(src proto.Message) {
	xxx_messageInfo_V4AddrPort.Merge(m, src)
}
func (m *V4AddrPort) XXX_Size() int {
	return m.Size()
}
func (m *V4AddrPort) XXX_DiscardUnknown() {
	xxx_messageInfo_V4AddrPort.DiscardUnknown(m)
}

var xxx_messageInfo_V4AddrPort proto.InternalMessageInfo

func (m *V4AddrPort) GetAddr() uint32 {
	if m != nil {
		return m.Addr
	}
	return 0
}

func (m *V4AddrPort) GetPort() uint32 {
	if m != nil {
		return m.Port
	}
	return 0
}

type V6AddrPort struct {
	Hi   uint64 `protobuf:"varint,1,opt,name=Hi,proto3" json:"Hi,omitempty"`
	Lo   uint64 `protobuf:"varint,2,opt,name=Lo,proto3" json:"Lo,omitempty"`
	Port uint32 `protobuf:"varint,3,opt,name=Port,proto3" json:"Port,omitempty"`
}

func (m *V6AddrPort) Reset()         { *m = V6AddrPort{} }
func (m *V6AddrPort) String() string { return proto.CompactTextString(m) }
func (*V6AddrPort) ProtoMessage()    {}
func (*V6AddrPort) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d65afa7693df5ef, []int{4}
}
func (m *V6AddrPort) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *V6AddrPort) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_V6AddrPort.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *V6AddrPort) XXX_Merge(src proto.Message) {
	xxx_messageInfo_V6AddrPort.Merge(m, src)
}
func (m *V6AddrPort) XXX_Size() int {
	return m.Size()
}
func (m *V6AddrPort) XXX_DiscardUnknown() {
	xxx_messageInfo_V6AddrPort.DiscardUnknown(m)
}

var xxx_messageInfo_V6AddrPort proto.InternalMessageInfo

func (m *V6AddrPort) GetHi() uint64 {
	if m != nil {
		return m.Hi
	}
	return 0
}

func (m *V6AddrPort) GetLo() uint64 {
	if m != nil {
		return m.Lo
	}
	return 0
}

func (m *V6AddrPort) GetPort() uint32 {
	if m != nil {
		return m.Port
	}
	return 0
}

type HandshakeFilteringWhitelist struct {
	AllowedHosts        []string        `protobuf:"bytes,1,rep,name=AllowedHosts,proto3" json:"AllowedHosts,omitempty"`
	AllowedGroups       []string        `protobuf:"bytes,2,rep,name=AllowedGroups,proto3" json:"AllowedGroups,omitempty"`
	AllowedGroupsCombos []*GroupsCombos `protobuf:"bytes,3,rep,name=AllowedGroupsCombos,proto3" json:"AllowedGroupsCombos,omitempty"`
	AllowedCidrs        []string        `protobuf:"bytes,4,rep,name=AllowedCidrs,proto3" json:"AllowedCidrs,omitempty"`
	AllowedCANames      []string        `protobuf:"bytes,5,rep,name=AllowedCANames,proto3" json:"AllowedCANames,omitempty"`
	AllowedCAShas       []string        `protobuf:"bytes,6,rep,name=AllowedCAShas,proto3" json:"AllowedCAShas,omitempty"`
	SetEmpty            bool            `protobuf:"varint,7,opt,name=SetEmpty,proto3" json:"SetEmpty,omitempty"`
}

func (m *HandshakeFilteringWhitelist) Reset()         { *m = HandshakeFilteringWhitelist{} }
func (m *HandshakeFilteringWhitelist) String() string { return proto.CompactTextString(m) }
func (*HandshakeFilteringWhitelist) ProtoMessage()    {}
func (*HandshakeFilteringWhitelist) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d65afa7693df5ef, []int{5}
}
func (m *HandshakeFilteringWhitelist) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *HandshakeFilteringWhitelist) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_HandshakeFilteringWhitelist.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *HandshakeFilteringWhitelist) XXX_Merge(src proto.Message) {
	xxx_messageInfo_HandshakeFilteringWhitelist.Merge(m, src)
}
func (m *HandshakeFilteringWhitelist) XXX_Size() int {
	return m.Size()
}
func (m *HandshakeFilteringWhitelist) XXX_DiscardUnknown() {
	xxx_messageInfo_HandshakeFilteringWhitelist.DiscardUnknown(m)
}

var xxx_messageInfo_HandshakeFilteringWhitelist proto.InternalMessageInfo

func (m *HandshakeFilteringWhitelist) GetAllowedHosts() []string {
	if m != nil {
		return m.AllowedHosts
	}
	return nil
}

func (m *HandshakeFilteringWhitelist) GetAllowedGroups() []string {
	if m != nil {
		return m.AllowedGroups
	}
	return nil
}

func (m *HandshakeFilteringWhitelist) GetAllowedGroupsCombos() []*GroupsCombos {
	if m != nil {
		return m.AllowedGroupsCombos
	}
	return nil
}

func (m *HandshakeFilteringWhitelist) GetAllowedCidrs() []string {
	if m != nil {
		return m.AllowedCidrs
	}
	return nil
}

func (m *HandshakeFilteringWhitelist) GetAllowedCANames() []string {
	if m != nil {
		return m.AllowedCANames
	}
	return nil
}

func (m *HandshakeFilteringWhitelist) GetAllowedCAShas() []string {
	if m != nil {
		return m.AllowedCAShas
	}
	return nil
}

func (m *HandshakeFilteringWhitelist) GetSetEmpty() bool {
	if m != nil {
		return m.SetEmpty
	}
	return false
}

type GroupsCombos struct {
	Group []string `protobuf:"bytes,1,rep,name=Group,proto3" json:"Group,omitempty"`
}

func (m *GroupsCombos) Reset()         { *m = GroupsCombos{} }
func (m *GroupsCombos) String() string { return proto.CompactTextString(m) }
func (*GroupsCombos) ProtoMessage()    {}
func (*GroupsCombos) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d65afa7693df5ef, []int{6}
}
func (m *GroupsCombos) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GroupsCombos) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GroupsCombos.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GroupsCombos) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GroupsCombos.Merge(m, src)
}
func (m *GroupsCombos) XXX_Size() int {
	return m.Size()
}
func (m *GroupsCombos) XXX_DiscardUnknown() {
	xxx_messageInfo_GroupsCombos.DiscardUnknown(m)
}

var xxx_messageInfo_GroupsCombos proto.InternalMessageInfo

func (m *GroupsCombos) GetGroup() []string {
	if m != nil {
		return m.Group
	}
	return nil
}

type NebulaPing struct {
	Type NebulaPing_MessageType `protobuf:"varint,1,opt,name=Type,proto3,enum=nebula.NebulaPing_MessageType" json:"Type,omitempty"`
	Time uint64                 `protobuf:"varint,2,opt,name=Time,proto3" json:"Time,omitempty"`
}

func (m *NebulaPing) Reset()         { *m = NebulaPing{} }
func (m *NebulaPing) String() string { return proto.CompactTextString(m) }
func (*NebulaPing) ProtoMessage()    {}
func (*NebulaPing) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d65afa7693df5ef, []int{7}
}
func (m *NebulaPing) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NebulaPing) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NebulaPing.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NebulaPing) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NebulaPing.Merge(m, src)
}
func (m *NebulaPing) XXX_Size() int {
	return m.Size()
}
func (m *NebulaPing) XXX_DiscardUnknown() {
	xxx_messageInfo_NebulaPing.DiscardUnknown(m)
}

var xxx_messageInfo_NebulaPing proto.InternalMessageInfo

func (m *NebulaPing) GetType() NebulaPing_MessageType {
	if m != nil {
		return m.Type
	}
	return NebulaPing_Ping
}

func (m *NebulaPing) GetTime() uint64 {
	if m != nil {
		return m.Time
	}
	return 0
}

type NebulaHandshake struct {
	Details *NebulaHandshakeDetails `protobuf:"bytes,1,opt,name=Details,proto3" json:"Details,omitempty"`
	Hmac    []byte                  `protobuf:"bytes,2,opt,name=Hmac,proto3" json:"Hmac,omitempty"`
}

func (m *NebulaHandshake) Reset()         { *m = NebulaHandshake{} }
func (m *NebulaHandshake) String() string { return proto.CompactTextString(m) }
func (*NebulaHandshake) ProtoMessage()    {}
func (*NebulaHandshake) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d65afa7693df5ef, []int{8}
}
func (m *NebulaHandshake) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NebulaHandshake) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NebulaHandshake.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NebulaHandshake) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NebulaHandshake.Merge(m, src)
}
func (m *NebulaHandshake) XXX_Size() int {
	return m.Size()
}
func (m *NebulaHandshake) XXX_DiscardUnknown() {
	xxx_messageInfo_NebulaHandshake.DiscardUnknown(m)
}

var xxx_messageInfo_NebulaHandshake proto.InternalMessageInfo

func (m *NebulaHandshake) GetDetails() *NebulaHandshakeDetails {
	if m != nil {
		return m.Details
	}
	return nil
}

func (m *NebulaHandshake) GetHmac() []byte {
	if m != nil {
		return m.Hmac
	}
	return nil
}

type NebulaHandshakeDetails struct {
	Cert           []byte `protobuf:"bytes,1,opt,name=Cert,proto3" json:"Cert,omitempty"`
	InitiatorIndex uint32 `protobuf:"varint,2,opt,name=InitiatorIndex,proto3" json:"InitiatorIndex,omitempty"`
	ResponderIndex uint32 `protobuf:"varint,3,opt,name=ResponderIndex,proto3" json:"ResponderIndex,omitempty"`
	Cookie         uint64 `protobuf:"varint,4,opt,name=Cookie,proto3" json:"Cookie,omitempty"`
	Time           uint64 `protobuf:"varint,5,opt,name=Time,proto3" json:"Time,omitempty"`
	CertVersion    uint32 `protobuf:"varint,8,opt,name=CertVersion,proto3" json:"CertVersion,omitempty"`
}

func (m *NebulaHandshakeDetails) Reset()         { *m = NebulaHandshakeDetails{} }
func (m *NebulaHandshakeDetails) String() string { return proto.CompactTextString(m) }
func (*NebulaHandshakeDetails) ProtoMessage()    {}
func (*NebulaHandshakeDetails) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d65afa7693df5ef, []int{9}
}
func (m *NebulaHandshakeDetails) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NebulaHandshakeDetails) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NebulaHandshakeDetails.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NebulaHandshakeDetails) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NebulaHandshakeDetails.Merge(m, src)
}
func (m *NebulaHandshakeDetails) XXX_Size() int {
	return m.Size()
}
func (m *NebulaHandshakeDetails) XXX_DiscardUnknown() {
	xxx_messageInfo_NebulaHandshakeDetails.DiscardUnknown(m)
}

var xxx_messageInfo_NebulaHandshakeDetails proto.InternalMessageInfo

func (m *NebulaHandshakeDetails) GetCert() []byte {
	if m != nil {
		return m.Cert
	}
	return nil
}

func (m *NebulaHandshakeDetails) GetInitiatorIndex() uint32 {
	if m != nil {
		return m.InitiatorIndex
	}
	return 0
}

func (m *NebulaHandshakeDetails) GetResponderIndex() uint32 {
	if m != nil {
		return m.ResponderIndex
	}
	return 0
}

func (m *NebulaHandshakeDetails) GetCookie() uint64 {
	if m != nil {
		return m.Cookie
	}
	return 0
}

func (m *NebulaHandshakeDetails) GetTime() uint64 {
	if m != nil {
		return m.Time
	}
	return 0
}

func (m *NebulaHandshakeDetails) GetCertVersion() uint32 {
	if m != nil {
		return m.CertVersion
	}
	return 0
}

type NebulaControl struct {
	Type                NebulaControl_MessageType `protobuf:"varint,1,opt,name=Type,proto3,enum=nebula.NebulaControl_MessageType" json:"Type,omitempty"`
	InitiatorRelayIndex uint32                    `protobuf:"varint,2,opt,name=InitiatorRelayIndex,proto3" json:"InitiatorRelayIndex,omitempty"`
	ResponderRelayIndex uint32                    `protobuf:"varint,3,opt,name=ResponderRelayIndex,proto3" json:"ResponderRelayIndex,omitempty"`
	OldRelayToAddr      uint32                    `protobuf:"varint,4,opt,name=OldRelayToAddr,proto3" json:"OldRelayToAddr,omitempty"`     // Deprecated: Do not use.
	OldRelayFromAddr    uint32                    `protobuf:"varint,5,opt,name=OldRelayFromAddr,proto3" json:"OldRelayFromAddr,omitempty"` // Deprecated: Do not use.
	RelayToAddr         *Addr                     `protobuf:"bytes,6,opt,name=RelayToAddr,proto3" json:"RelayToAddr,omitempty"`
	RelayFromAddr       *Addr                     `protobuf:"bytes,7,opt,name=RelayFromAddr,proto3" json:"RelayFromAddr,omitempty"`
}

func (m *NebulaControl) Reset()         { *m = NebulaControl{} }
func (m *NebulaControl) String() string { return proto.CompactTextString(m) }
func (*NebulaControl) ProtoMessage()    {}
func (*NebulaControl) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d65afa7693df5ef, []int{10}
}
func (m *NebulaControl) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NebulaControl) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NebulaControl.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NebulaControl) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NebulaControl.Merge(m, src)
}
func (m *NebulaControl) XXX_Size() int {
	return m.Size()
}
func (m *NebulaControl) XXX_DiscardUnknown() {
	xxx_messageInfo_NebulaControl.DiscardUnknown(m)
}

var xxx_messageInfo_NebulaControl proto.InternalMessageInfo

func (m *NebulaControl) GetType() NebulaControl_MessageType {
	if m != nil {
		return m.Type
	}
	return NebulaControl_None
}

func (m *NebulaControl) GetInitiatorRelayIndex() uint32 {
	if m != nil {
		return m.InitiatorRelayIndex
	}
	return 0
}

func (m *NebulaControl) GetResponderRelayIndex() uint32 {
	if m != nil {
		return m.ResponderRelayIndex
	}
	return 0
}

// Deprecated: Do not use.
func (m *NebulaControl) GetOldRelayToAddr() uint32 {
	if m != nil {
		return m.OldRelayToAddr
	}
	return 0
}

// Deprecated: Do not use.
func (m *NebulaControl) GetOldRelayFromAddr() uint32 {
	if m != nil {
		return m.OldRelayFromAddr
	}
	return 0
}

func (m *NebulaControl) GetRelayToAddr() *Addr {
	if m != nil {
		return m.RelayToAddr
	}
	return nil
}

func (m *NebulaControl) GetRelayFromAddr() *Addr {
	if m != nil {
		return m.RelayFromAddr
	}
	return nil
}

func init() {
	proto.RegisterEnum("nebula.NebulaMeta_MessageType", NebulaMeta_MessageType_name, NebulaMeta_MessageType_value)
	proto.RegisterEnum("nebula.NebulaPing_MessageType", NebulaPing_MessageType_name, NebulaPing_MessageType_value)
	proto.RegisterEnum("nebula.NebulaControl_MessageType", NebulaControl_MessageType_name, NebulaControl_MessageType_value)
	proto.RegisterType((*NebulaMeta)(nil), "nebula.NebulaMeta")
	proto.RegisterType((*NebulaMetaDetails)(nil), "nebula.NebulaMetaDetails")
	proto.RegisterType((*Addr)(nil), "nebula.Addr")
	proto.RegisterType((*V4AddrPort)(nil), "nebula.V4AddrPort")
	proto.RegisterType((*V6AddrPort)(nil), "nebula.V6AddrPort")
	proto.RegisterType((*HandshakeFilteringWhitelist)(nil), "nebula.HandshakeFilteringWhitelist")
	proto.RegisterType((*GroupsCombos)(nil), "nebula.GroupsCombos")
	proto.RegisterType((*NebulaPing)(nil), "nebula.NebulaPing")
	proto.RegisterType((*NebulaHandshake)(nil), "nebula.NebulaHandshake")
	proto.RegisterType((*NebulaHandshakeDetails)(nil), "nebula.NebulaHandshakeDetails")
	proto.RegisterType((*NebulaControl)(nil), "nebula.NebulaControl")
}

func init() { proto.RegisterFile("nebula.proto", fileDescriptor_2d65afa7693df5ef) }

var fileDescriptor_2d65afa7693df5ef = []byte{
	// 949 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x84, 0x56, 0xcd, 0x72, 0x1b, 0x45,
	0x10, 0xd6, 0x4a, 0xab, 0xbf, 0xd6, 0x4f, 0x96, 0x76, 0x30, 0xeb, 0x50, 0xa8, 0xc4, 0x92, 0x72,
	0xb9, 0x38, 0x28, 0x94, 0x6d, 0x52, 0x1c, 0x51, 0x04, 0x46, 0x49, 0xc5, 0x8e, 0x99, 0x18, 0xa7,
	0x8a, 0x0b, 0xb5, 0xd6, 0x0e, 0xde, 0x29, 0xad, 0x76, 0x94, 0xdd, 0x11, 0x44, 0x6f, 0xc1, 0xa3,
	0x70, 0xe0, 0xca, 0x9d, 0x63, 0x4e, 0x14, 0x47, 0xca, 0x3e, 0x72, 0xe4, 0x05, 0xa8, 0x99, 0xfd,
	0x97, 0x16, 0xe7, 0x36, 0xdd, 0xfd, 0x75, 0xef, 0x37, 0x5f, 0xb7, 0x7a, 0x04, 0x5d, 0x9f, 0x5e,
	0xad, 0x3c, 0x7b, 0xb4, 0x0c, 0xb8, 0xe0, 0xd8, 0x88, 0x2c, 0xeb, 0x9f, 0x2a, 0xc0, 0x99, 0x3a,
	0x9e, 0x52, 0x61, 0xe3, 0x21, 0xe8, 0x17, 0xeb, 0x25, 0x35, 0xb5, 0xa1, 0x76, 0xd0, 0x3f, 0x1c,
	0x8c, 0xe2, 0x9c, 0x0c, 0x31, 0x3a, 0xa5, 0x61, 0x68, 0x5f, 0x53, 0x89, 0x22, 0x0a, 0x8b, 0x47,
	0xd0, 0xfc, 0x8a, 0x0a, 0x9b, 0x79, 0xa1, 0x59, 0x1d, 0x6a, 0x07, 0x9d, 0xc3, 0xbd, 0xed, 0xb4,
	0x18, 0x40, 0x12, 0xa4, 0xf5, 0xaf, 0x06, 0x9d, 0x5c, 0x29, 0x6c, 0x81, 0x7e, 0xc6, 0x7d, 0x6a,
	0x54, 0xb0, 0x07, 0xed, 0x29, 0x0f, 0xc5, 0xb7, 0x2b, 0x1a, 0xac, 0x0d, 0x0d, 0x11, 0xfa, 0xa9,
	0x49, 0xe8, 0xd2, 0x5b, 0x1b, 0x55, 0x7c, 0x00, 0xbb, 0xd2, 0xf7, 0xdd, 0xd2, 0xb1, 0x05, 0x3d,
	0xe3, 0x82, 0xfd, 0xc8, 0x66, 0xb6, 0x60, 0xdc, 0x37, 0x6a, 0xb8, 0x07, 0xef, 0xcb, 0xd8, 0x29,
	0xff, 0x89, 0x3a, 0x85, 0x90, 0x9e, 0x84, 0xce, 0x57, 0xfe, 0xcc, 0x2d, 0x84, 0xea, 0xd8, 0x07,
	0x90, 0xa1, 0x57, 0x2e, 0xb7, 0x17, 0xcc, 0x68, 0xe0, 0x0e, 0xdc, 0xcb, 0xec, 0xe8, 0xb3, 0x4d,
	0xc9, 0xec, 0xdc, 0x16, 0xee, 0xc4, 0xa5, 0xb3, 0xb9, 0xd1, 0x92, 0xcc, 0x52, 0x33, 0x82, 0xb4,
	0xf1, 0x23, 0xd8, 0x2b, 0x67, 0x36, 0x9e, 0xcd, 0x0d, 0xb0, 0x7e, 0xad, 0xc1, 0x7b, 0x5b, 0xa2,
	0xa0, 0x05, 0xf0, 0xc2, 0x73, 0x2e, 0x97, 0xfe, 0xd8, 0x71, 0x02, 0x25, 0x7d, 0xef, 0x49, 0xd5,
	0xd4, 0x48, 0xce, 0x8b, 0xfb, 0xd0, 0x4c, 0x00, 0x0d, 0x25, 0x72, 0x37, 0x11, 0x59, 0xfa, 0x48,
	0x12, 0xc4, 0x11, 0x18, 0x2f, 0x3c, 0x87, 0x50, 0xcf, 0x5e, 0xc7, 0xae, 0xd0, 0xac, 0x0f, 0x6b,
	0x71, 0xc5, 0xad, 0x18, 0x1e, 0x42, 0xaf, 0x08, 0x6e, 0x0e, 0x6b, 0x5b, 0xd5, 0x8b, 0x10, 0xa4,
	0xf0, 0xe1, 0xd4, 0xf6, 0x9d, 0xd0, 0xb5, 0xe7, 0xf4, 0x84, 0x79, 0x82, 0x06, 0xcc, 0xbf, 0x7e,
	0xe5, 0x32, 0x41, 0x3d, 0x16, 0x0a, 0xb3, 0xa5, 0xf8, 0x7d, 0x92, 0x54, 0xb8, 0x03, 0x4a, 0xee,
	0xaa, 0x83, 0xc7, 0xd0, 0xb9, 0x3c, 0x96, 0x5f, 0x3c, 0xe7, 0x81, 0x90, 0xb3, 0x25, 0x89, 0x61,
	0x52, 0x36, 0x0b, 0x91, 0x3c, 0x4c, 0x65, 0x3d, 0xce, 0xb2, 0xf4, 0x8d, 0xac, 0xc7, 0xb9, 0xac,
	0x0c, 0x86, 0x26, 0x34, 0x67, 0x7c, 0xe5, 0x0b, 0x1a, 0x98, 0x35, 0xa9, 0x3f, 0x49, 0x4c, 0x6b,
	0x1f, 0x74, 0x25, 0x6c, 0x1f, 0xaa, 0x53, 0xa6, 0x9a, 0xa3, 0x93, 0xea, 0x94, 0x49, 0xfb, 0x39,
	0x57, 0x03, 0xaf, 0x93, 0xea, 0x73, 0x6e, 0x1d, 0x03, 0x64, 0x34, 0x10, 0xa3, 0xac, 0xa8, 0x99,
	0x24, 0xaa, 0x80, 0xa0, 0xcb, 0x98, 0xca, 0xe9, 0x11, 0x75, 0xb6, 0xbe, 0x04, 0xc8, 0x68, 0xbc,
	0xeb, 0x1b, 0x69, 0x85, 0x5a, 0xae, 0xc2, 0xef, 0xd5, 0x3b, 0xbb, 0x81, 0x16, 0x74, 0xc7, 0x9e,
	0xc7, 0x7f, 0xa6, 0x8e, 0x1c, 0xcc, 0xd0, 0xd4, 0x86, 0xb5, 0x83, 0x36, 0x29, 0xf8, 0xf0, 0x21,
	0xf4, 0x62, 0xfb, 0x9b, 0x80, 0xaf, 0x96, 0x91, 0xd6, 0x6d, 0x52, 0x74, 0xe2, 0x09, 0xec, 0x14,
	0x1c, 0x13, 0xbe, 0xb8, 0xe2, 0xa1, 0x59, 0x53, 0x0a, 0xdf, 0x4f, 0x14, 0xce, 0xc7, 0x48, 0x59,
	0x42, 0x8e, 0xd1, 0x84, 0xc9, 0x89, 0xd3, 0x0b, 0x8c, 0x94, 0x0f, 0xf7, 0xa1, 0x9f, 0xd8, 0xe3,
	0x33, 0x7b, 0x41, 0xa3, 0x21, 0x6e, 0x93, 0x0d, 0x6f, 0x8e, 0xf9, 0x64, 0xfc, 0xd2, 0xb5, 0x43,
	0xb3, 0x51, 0x60, 0x1e, 0x39, 0xf1, 0x01, 0xb4, 0x5e, 0x52, 0xf1, 0xf5, 0x62, 0x29, 0xd6, 0x66,
	0x73, 0xa8, 0x1d, 0xb4, 0x48, 0x6a, 0x5b, 0x0f, 0xa1, 0x5b, 0x60, 0x77, 0x1f, 0xea, 0xca, 0x8e,
	0x85, 0x8a, 0x0c, 0xeb, 0x4d, 0xb2, 0x25, 0xcf, 0x99, 0x7f, 0x7d, 0xf7, 0x96, 0x94, 0x88, 0x92,
	0x2d, 0x89, 0xa0, 0x5f, 0xb0, 0x05, 0x8d, 0xbb, 0xa9, 0xce, 0x96, 0xb5, 0xb5, 0x03, 0x65, 0xb2,
	0x51, 0xc1, 0x36, 0xd4, 0xa3, 0x8d, 0xa2, 0x59, 0x3f, 0xc0, 0xbd, 0xa8, 0x6e, 0xda, 0x64, 0xfc,
	0x22, 0x5b, 0xb8, 0x9a, 0xfa, 0xad, 0x6d, 0x30, 0x48, 0x91, 0x9b, 0x5b, 0x57, 0x92, 0x98, 0x2e,
	0xec, 0x99, 0x22, 0xd1, 0x25, 0xea, 0x6c, 0xfd, 0xa9, 0xc1, 0x6e, 0x79, 0x9e, 0x84, 0x4f, 0x68,
	0x20, 0xd4, 0x57, 0xba, 0x44, 0x9d, 0x65, 0x67, 0x9e, 0xfa, 0x4c, 0x30, 0x5b, 0xf0, 0xe0, 0xa9,
	0xef, 0xd0, 0x37, 0xf1, 0x3c, 0x6f, 0x78, 0x25, 0x8e, 0xd0, 0x70, 0xc9, 0x7d, 0x87, 0xc6, 0xb8,
	0x68, 0x6a, 0x37, 0xbc, 0xb8, 0x0b, 0x8d, 0x09, 0xe7, 0x73, 0x46, 0x4d, 0x5d, 0x29, 0x13, 0x5b,
	0xa9, 0x5e, 0xf5, 0x4c, 0x2f, 0x1c, 0x42, 0x47, 0x72, 0xb8, 0xa4, 0x41, 0xc8, 0xb8, 0xaf, 0x16,
	0x4d, 0x8f, 0xe4, 0x5d, 0xcf, 0xf4, 0x56, 0xc3, 0x68, 0x3e, 0xd3, 0x5b, 0x4d, 0xa3, 0x65, 0xfd,
	0x56, 0x83, 0x5e, 0x74, 0xb1, 0x09, 0xf7, 0x45, 0xc0, 0x3d, 0xfc, 0xbc, 0xd0, 0xb7, 0x8f, 0x8b,
	0xaa, 0xc5, 0xa0, 0x92, 0xd6, 0x7d, 0x06, 0x3b, 0xe9, 0xe5, 0xd4, 0x26, 0xcc, 0xdf, 0xbb, 0x2c,
	0x24, 0x33, 0xd2, 0x6b, 0xe6, 0x32, 0x22, 0x05, 0xca, 0x42, 0xf8, 0x29, 0xf4, 0x93, 0xdd, 0x7c,
	0xc1, 0xd5, 0xea, 0xd0, 0xd3, 0x77, 0x60, 0x23, 0x92, 0xdf, 0xf1, 0x27, 0x01, 0x5f, 0x28, 0x74,
	0x3d, 0x45, 0x6f, 0xc5, 0x70, 0x04, 0x9d, 0x7c, 0xe1, 0xb2, 0xf7, 0x23, 0x0f, 0x48, 0xdf, 0x84,
	0xb4, 0x78, 0xb3, 0x24, 0xa3, 0x08, 0xb1, 0xa6, 0xff, 0xf7, 0x9c, 0xef, 0x02, 0x4e, 0x02, 0x6a,
	0x0b, 0xaa, 0xf0, 0x84, 0xbe, 0x5e, 0xd1, 0x50, 0x18, 0x1a, 0x7e, 0x00, 0x3b, 0x05, 0xbf, 0x94,
	0x24, 0xa4, 0x46, 0xf5, 0xc9, 0xd1, 0x1f, 0x37, 0x03, 0xed, 0xed, 0xcd, 0x40, 0xfb, 0xfb, 0x66,
	0xa0, 0xfd, 0x72, 0x3b, 0xa8, 0xbc, 0xbd, 0x1d, 0x54, 0xfe, 0xba, 0x1d, 0x54, 0xbe, 0xdf, 0xbb,
	0x66, 0xc2, 0x5d, 0x5d, 0x8d, 0x66, 0x7c, 0xf1, 0x28, 0xf4, 0xec, 0xd9, 0xdc, 0x7d, 0xfd, 0x28,
	0xa2, 0x74, 0xd5, 0x50, 0xff, 0x6a, 0x8e, 0xfe, 0x0b, 0x00, 0x00, 0xff, 0xff, 0x6f, 0xb9, 0x8e,
	0x82, 0xe5, 0x08, 0x00, 0x00,
}

func (m *NebulaMeta) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NebulaMeta) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NebulaMeta) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Details != nil {
		{
			size, err := m.Details.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintNebula(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Type != 0 {
		i = encodeVarintNebula(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *NebulaMetaDetails) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NebulaMetaDetails) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NebulaMetaDetails) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.HandshakeFilteringWhitelist != nil {
		{
			size, err := m.HandshakeFilteringWhitelist.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintNebula(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	if len(m.RelayVpnAddrs) > 0 {
		for iNdEx := len(m.RelayVpnAddrs) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.RelayVpnAddrs[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintNebula(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x3a
		}
	}
	if m.VpnAddr != nil {
		{
			size, err := m.VpnAddr.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintNebula(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if len(m.OldRelayVpnAddrs) > 0 {
		dAtA5 := make([]byte, len(m.OldRelayVpnAddrs)*10)
		var j4 int
		for _, num := range m.OldRelayVpnAddrs {
			for num >= 1<<7 {
				dAtA5[j4] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j4++
			}
			dAtA5[j4] = uint8(num)
			j4++
		}
		i -= j4
		copy(dAtA[i:], dAtA5[:j4])
		i = encodeVarintNebula(dAtA, i, uint64(j4))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.V6AddrPorts) > 0 {
		for iNdEx := len(m.V6AddrPorts) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.V6AddrPorts[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintNebula(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if m.Counter != 0 {
		i = encodeVarintNebula(dAtA, i, uint64(m.Counter))
		i--
		dAtA[i] = 0x18
	}
	if len(m.V4AddrPorts) > 0 {
		for iNdEx := len(m.V4AddrPorts) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.V4AddrPorts[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintNebula(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.OldVpnAddr != 0 {
		i = encodeVarintNebula(dAtA, i, uint64(m.OldVpnAddr))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Addr) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Addr) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Addr) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Lo != 0 {
		i = encodeVarintNebula(dAtA, i, uint64(m.Lo))
		i--
		dAtA[i] = 0x10
	}
	if m.Hi != 0 {
		i = encodeVarintNebula(dAtA, i, uint64(m.Hi))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *V4AddrPort) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *V4AddrPort) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *V4AddrPort) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Port != 0 {
		i = encodeVarintNebula(dAtA, i, uint64(m.Port))
		i--
		dAtA[i] = 0x10
	}
	if m.Addr != 0 {
		i = encodeVarintNebula(dAtA, i, uint64(m.Addr))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *V6AddrPort) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *V6AddrPort) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *V6AddrPort) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Port != 0 {
		i = encodeVarintNebula(dAtA, i, uint64(m.Port))
		i--
		dAtA[i] = 0x18
	}
	if m.Lo != 0 {
		i = encodeVarintNebula(dAtA, i, uint64(m.Lo))
		i--
		dAtA[i] = 0x10
	}
	if m.Hi != 0 {
		i = encodeVarintNebula(dAtA, i, uint64(m.Hi))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *HandshakeFilteringWhitelist) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HandshakeFilteringWhitelist) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *HandshakeFilteringWhitelist) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.SetEmpty {
		i--
		if m.SetEmpty {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x38
	}
	if len(m.AllowedCAShas) > 0 {
		for iNdEx := len(m.AllowedCAShas) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.AllowedCAShas[iNdEx])
			copy(dAtA[i:], m.AllowedCAShas[iNdEx])
			i = encodeVarintNebula(dAtA, i, uint64(len(m.AllowedCAShas[iNdEx])))
			i--
			dAtA[i] = 0x32
		}
	}
	if len(m.AllowedCANames) > 0 {
		for iNdEx := len(m.AllowedCANames) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.AllowedCANames[iNdEx])
			copy(dAtA[i:], m.AllowedCANames[iNdEx])
			i = encodeVarintNebula(dAtA, i, uint64(len(m.AllowedCANames[iNdEx])))
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.AllowedCidrs) > 0 {
		for iNdEx := len(m.AllowedCidrs) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.AllowedCidrs[iNdEx])
			copy(dAtA[i:], m.AllowedCidrs[iNdEx])
			i = encodeVarintNebula(dAtA, i, uint64(len(m.AllowedCidrs[iNdEx])))
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.AllowedGroupsCombos) > 0 {
		for iNdEx := len(m.AllowedGroupsCombos) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.AllowedGroupsCombos[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintNebula(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.AllowedGroups) > 0 {
		for iNdEx := len(m.AllowedGroups) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.AllowedGroups[iNdEx])
			copy(dAtA[i:], m.AllowedGroups[iNdEx])
			i = encodeVarintNebula(dAtA, i, uint64(len(m.AllowedGroups[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.AllowedHosts) > 0 {
		for iNdEx := len(m.AllowedHosts) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.AllowedHosts[iNdEx])
			copy(dAtA[i:], m.AllowedHosts[iNdEx])
			i = encodeVarintNebula(dAtA, i, uint64(len(m.AllowedHosts[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *GroupsCombos) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GroupsCombos) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GroupsCombos) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Group) > 0 {
		for iNdEx := len(m.Group) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Group[iNdEx])
			copy(dAtA[i:], m.Group[iNdEx])
			i = encodeVarintNebula(dAtA, i, uint64(len(m.Group[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *NebulaPing) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NebulaPing) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NebulaPing) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Time != 0 {
		i = encodeVarintNebula(dAtA, i, uint64(m.Time))
		i--
		dAtA[i] = 0x10
	}
	if m.Type != 0 {
		i = encodeVarintNebula(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *NebulaHandshake) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NebulaHandshake) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NebulaHandshake) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Hmac) > 0 {
		i -= len(m.Hmac)
		copy(dAtA[i:], m.Hmac)
		i = encodeVarintNebula(dAtA, i, uint64(len(m.Hmac)))
		i--
		dAtA[i] = 0x12
	}
	if m.Details != nil {
		{
			size, err := m.Details.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintNebula(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *NebulaHandshakeDetails) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NebulaHandshakeDetails) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NebulaHandshakeDetails) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.CertVersion != 0 {
		i = encodeVarintNebula(dAtA, i, uint64(m.CertVersion))
		i--
		dAtA[i] = 0x40
	}
	if m.Time != 0 {
		i = encodeVarintNebula(dAtA, i, uint64(m.Time))
		i--
		dAtA[i] = 0x28
	}
	if m.Cookie != 0 {
		i = encodeVarintNebula(dAtA, i, uint64(m.Cookie))
		i--
		dAtA[i] = 0x20
	}
	if m.ResponderIndex != 0 {
		i = encodeVarintNebula(dAtA, i, uint64(m.ResponderIndex))
		i--
		dAtA[i] = 0x18
	}
	if m.InitiatorIndex != 0 {
		i = encodeVarintNebula(dAtA, i, uint64(m.InitiatorIndex))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Cert) > 0 {
		i -= len(m.Cert)
		copy(dAtA[i:], m.Cert)
		i = encodeVarintNebula(dAtA, i, uint64(len(m.Cert)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *NebulaControl) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NebulaControl) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NebulaControl) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.RelayFromAddr != nil {
		{
			size, err := m.RelayFromAddr.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintNebula(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	if m.RelayToAddr != nil {
		{
			size, err := m.RelayToAddr.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintNebula(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if m.OldRelayFromAddr != 0 {
		i = encodeVarintNebula(dAtA, i, uint64(m.OldRelayFromAddr))
		i--
		dAtA[i] = 0x28
	}
	if m.OldRelayToAddr != 0 {
		i = encodeVarintNebula(dAtA, i, uint64(m.OldRelayToAddr))
		i--
		dAtA[i] = 0x20
	}
	if m.ResponderRelayIndex != 0 {
		i = encodeVarintNebula(dAtA, i, uint64(m.ResponderRelayIndex))
		i--
		dAtA[i] = 0x18
	}
	if m.InitiatorRelayIndex != 0 {
		i = encodeVarintNebula(dAtA, i, uint64(m.InitiatorRelayIndex))
		i--
		dAtA[i] = 0x10
	}
	if m.Type != 0 {
		i = encodeVarintNebula(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func encodeVarintNebula(dAtA []byte, offset int, v uint64) int {
	offset -= sovNebula(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *NebulaMeta) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovNebula(uint64(m.Type))
	}
	if m.Details != nil {
		l = m.Details.Size()
		n += 1 + l + sovNebula(uint64(l))
	}
	return n
}

func (m *NebulaMetaDetails) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.OldVpnAddr != 0 {
		n += 1 + sovNebula(uint64(m.OldVpnAddr))
	}
	if len(m.V4AddrPorts) > 0 {
		for _, e := range m.V4AddrPorts {
			l = e.Size()
			n += 1 + l + sovNebula(uint64(l))
		}
	}
	if m.Counter != 0 {
		n += 1 + sovNebula(uint64(m.Counter))
	}
	if len(m.V6AddrPorts) > 0 {
		for _, e := range m.V6AddrPorts {
			l = e.Size()
			n += 1 + l + sovNebula(uint64(l))
		}
	}
	if len(m.OldRelayVpnAddrs) > 0 {
		l = 0
		for _, e := range m.OldRelayVpnAddrs {
			l += sovNebula(uint64(e))
		}
		n += 1 + sovNebula(uint64(l)) + l
	}
	if m.VpnAddr != nil {
		l = m.VpnAddr.Size()
		n += 1 + l + sovNebula(uint64(l))
	}
	if len(m.RelayVpnAddrs) > 0 {
		for _, e := range m.RelayVpnAddrs {
			l = e.Size()
			n += 1 + l + sovNebula(uint64(l))
		}
	}
	if m.HandshakeFilteringWhitelist != nil {
		l = m.HandshakeFilteringWhitelist.Size()
		n += 1 + l + sovNebula(uint64(l))
	}
	return n
}

func (m *Addr) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Hi != 0 {
		n += 1 + sovNebula(uint64(m.Hi))
	}
	if m.Lo != 0 {
		n += 1 + sovNebula(uint64(m.Lo))
	}
	return n
}

func (m *V4AddrPort) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Addr != 0 {
		n += 1 + sovNebula(uint64(m.Addr))
	}
	if m.Port != 0 {
		n += 1 + sovNebula(uint64(m.Port))
	}
	return n
}

func (m *V6AddrPort) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Hi != 0 {
		n += 1 + sovNebula(uint64(m.Hi))
	}
	if m.Lo != 0 {
		n += 1 + sovNebula(uint64(m.Lo))
	}
	if m.Port != 0 {
		n += 1 + sovNebula(uint64(m.Port))
	}
	return n
}

func (m *HandshakeFilteringWhitelist) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.AllowedHosts) > 0 {
		for _, s := range m.AllowedHosts {
			l = len(s)
			n += 1 + l + sovNebula(uint64(l))
		}
	}
	if len(m.AllowedGroups) > 0 {
		for _, s := range m.AllowedGroups {
			l = len(s)
			n += 1 + l + sovNebula(uint64(l))
		}
	}
	if len(m.AllowedGroupsCombos) > 0 {
		for _, e := range m.AllowedGroupsCombos {
			l = e.Size()
			n += 1 + l + sovNebula(uint64(l))
		}
	}
	if len(m.AllowedCidrs) > 0 {
		for _, s := range m.AllowedCidrs {
			l = len(s)
			n += 1 + l + sovNebula(uint64(l))
		}
	}
	if len(m.AllowedCANames) > 0 {
		for _, s := range m.AllowedCANames {
			l = len(s)
			n += 1 + l + sovNebula(uint64(l))
		}
	}
	if len(m.AllowedCAShas) > 0 {
		for _, s := range m.AllowedCAShas {
			l = len(s)
			n += 1 + l + sovNebula(uint64(l))
		}
	}
	if m.SetEmpty {
		n += 2
	}
	return n
}

func (m *GroupsCombos) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Group) > 0 {
		for _, s := range m.Group {
			l = len(s)
			n += 1 + l + sovNebula(uint64(l))
		}
	}
	return n
}

func (m *NebulaPing) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovNebula(uint64(m.Type))
	}
	if m.Time != 0 {
		n += 1 + sovNebula(uint64(m.Time))
	}
	return n
}

func (m *NebulaHandshake) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Details != nil {
		l = m.Details.Size()
		n += 1 + l + sovNebula(uint64(l))
	}
	l = len(m.Hmac)
	if l > 0 {
		n += 1 + l + sovNebula(uint64(l))
	}
	return n
}

func (m *NebulaHandshakeDetails) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Cert)
	if l > 0 {
		n += 1 + l + sovNebula(uint64(l))
	}
	if m.InitiatorIndex != 0 {
		n += 1 + sovNebula(uint64(m.InitiatorIndex))
	}
	if m.ResponderIndex != 0 {
		n += 1 + sovNebula(uint64(m.ResponderIndex))
	}
	if m.Cookie != 0 {
		n += 1 + sovNebula(uint64(m.Cookie))
	}
	if m.Time != 0 {
		n += 1 + sovNebula(uint64(m.Time))
	}
	if m.CertVersion != 0 {
		n += 1 + sovNebula(uint64(m.CertVersion))
	}
	return n
}

func (m *NebulaControl) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovNebula(uint64(m.Type))
	}
	if m.InitiatorRelayIndex != 0 {
		n += 1 + sovNebula(uint64(m.InitiatorRelayIndex))
	}
	if m.ResponderRelayIndex != 0 {
		n += 1 + sovNebula(uint64(m.ResponderRelayIndex))
	}
	if m.OldRelayToAddr != 0 {
		n += 1 + sovNebula(uint64(m.OldRelayToAddr))
	}
	if m.OldRelayFromAddr != 0 {
		n += 1 + sovNebula(uint64(m.OldRelayFromAddr))
	}
	if m.RelayToAddr != nil {
		l = m.RelayToAddr.Size()
		n += 1 + l + sovNebula(uint64(l))
	}
	if m.RelayFromAddr != nil {
		l = m.RelayFromAddr.Size()
		n += 1 + l + sovNebula(uint64(l))
	}
	return n
}

func sovNebula(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozNebula(x uint64) (n int) {
	return sovNebula(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *NebulaMeta) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNebula
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NebulaMeta: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NebulaMeta: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNebula
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= NebulaMeta_MessageType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Details", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNebula
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNebula
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNebula
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Details == nil {
				m.Details = &NebulaMetaDetails{}
			}
			if err := m.Details.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNebula(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthNebula
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NebulaMetaDetails) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNebula
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NebulaMetaDetails: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NebulaMetaDetails: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OldVpnAddr", wireType)
			}
			m.OldVpnAddr = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNebula
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OldVpnAddr |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field V4AddrPorts", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNebula
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNebula
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNebula
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.V4AddrPorts = append(m.V4AddrPorts, &V4AddrPort{})
			if err := m.V4AddrPorts[len(m.V4AddrPorts)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Counter", wireType)
			}
			m.Counter = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNebula
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Counter |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field V6AddrPorts", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNebula
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNebula
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNebula
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.V6AddrPorts = append(m.V6AddrPorts, &V6AddrPort{})
			if err := m.V6AddrPorts[len(m.V6AddrPorts)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType == 0 {
				var v uint32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowNebula
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.OldRelayVpnAddrs = append(m.OldRelayVpnAddrs, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowNebula
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthNebula
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthNebula
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.OldRelayVpnAddrs) == 0 {
					m.OldRelayVpnAddrs = make([]uint32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowNebula
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.OldRelayVpnAddrs = append(m.OldRelayVpnAddrs, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field OldRelayVpnAddrs", wireType)
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VpnAddr", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNebula
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNebula
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNebula
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.VpnAddr == nil {
				m.VpnAddr = &Addr{}
			}
			if err := m.VpnAddr.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RelayVpnAddrs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNebula
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNebula
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNebula
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RelayVpnAddrs = append(m.RelayVpnAddrs, &Addr{})
			if err := m.RelayVpnAddrs[len(m.RelayVpnAddrs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HandshakeFilteringWhitelist", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNebula
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNebula
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNebula
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.HandshakeFilteringWhitelist == nil {
				m.HandshakeFilteringWhitelist = &HandshakeFilteringWhitelist{}
			}
			if err := m.HandshakeFilteringWhitelist.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNebula(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthNebula
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Addr) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNebula
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Addr: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Addr: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hi", wireType)
			}
			m.Hi = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNebula
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Hi |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Lo", wireType)
			}
			m.Lo = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNebula
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Lo |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipNebula(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthNebula
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *V4AddrPort) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNebula
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: V4AddrPort: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: V4AddrPort: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Addr", wireType)
			}
			m.Addr = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNebula
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Addr |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Port", wireType)
			}
			m.Port = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNebula
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Port |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipNebula(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthNebula
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *V6AddrPort) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNebula
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: V6AddrPort: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: V6AddrPort: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hi", wireType)
			}
			m.Hi = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNebula
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Hi |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Lo", wireType)
			}
			m.Lo = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNebula
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Lo |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Port", wireType)
			}
			m.Port = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNebula
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Port |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipNebula(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthNebula
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HandshakeFilteringWhitelist) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNebula
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HandshakeFilteringWhitelist: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HandshakeFilteringWhitelist: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AllowedHosts", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNebula
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNebula
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNebula
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AllowedHosts = append(m.AllowedHosts, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AllowedGroups", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNebula
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNebula
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNebula
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AllowedGroups = append(m.AllowedGroups, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AllowedGroupsCombos", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNebula
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNebula
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNebula
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AllowedGroupsCombos = append(m.AllowedGroupsCombos, &GroupsCombos{})
			if err := m.AllowedGroupsCombos[len(m.AllowedGroupsCombos)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AllowedCidrs", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNebula
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNebula
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNebula
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AllowedCidrs = append(m.AllowedCidrs, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AllowedCANames", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNebula
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNebula
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNebula
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AllowedCANames = append(m.AllowedCANames, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AllowedCAShas", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNebula
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNebula
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNebula
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AllowedCAShas = append(m.AllowedCAShas, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SetEmpty", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNebula
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.SetEmpty = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipNebula(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthNebula
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GroupsCombos) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNebula
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GroupsCombos: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GroupsCombos: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Group", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNebula
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNebula
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNebula
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Group = append(m.Group, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNebula(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthNebula
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NebulaPing) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNebula
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NebulaPing: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NebulaPing: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNebula
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= NebulaPing_MessageType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Time", wireType)
			}
			m.Time = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNebula
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Time |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipNebula(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthNebula
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NebulaHandshake) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNebula
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NebulaHandshake: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NebulaHandshake: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Details", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNebula
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNebula
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNebula
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Details == nil {
				m.Details = &NebulaHandshakeDetails{}
			}
			if err := m.Details.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hmac", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNebula
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthNebula
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthNebula
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Hmac = append(m.Hmac[:0], dAtA[iNdEx:postIndex]...)
			if m.Hmac == nil {
				m.Hmac = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNebula(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthNebula
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NebulaHandshakeDetails) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNebula
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NebulaHandshakeDetails: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NebulaHandshakeDetails: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cert", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNebula
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthNebula
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthNebula
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Cert = append(m.Cert[:0], dAtA[iNdEx:postIndex]...)
			if m.Cert == nil {
				m.Cert = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InitiatorIndex", wireType)
			}
			m.InitiatorIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNebula
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.InitiatorIndex |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResponderIndex", wireType)
			}
			m.ResponderIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNebula
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ResponderIndex |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cookie", wireType)
			}
			m.Cookie = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNebula
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Cookie |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Time", wireType)
			}
			m.Time = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNebula
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Time |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CertVersion", wireType)
			}
			m.CertVersion = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNebula
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CertVersion |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipNebula(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthNebula
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NebulaControl) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNebula
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NebulaControl: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NebulaControl: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNebula
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= NebulaControl_MessageType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InitiatorRelayIndex", wireType)
			}
			m.InitiatorRelayIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNebula
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.InitiatorRelayIndex |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResponderRelayIndex", wireType)
			}
			m.ResponderRelayIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNebula
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ResponderRelayIndex |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OldRelayToAddr", wireType)
			}
			m.OldRelayToAddr = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNebula
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OldRelayToAddr |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OldRelayFromAddr", wireType)
			}
			m.OldRelayFromAddr = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNebula
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OldRelayFromAddr |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RelayToAddr", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNebula
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNebula
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNebula
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RelayToAddr == nil {
				m.RelayToAddr = &Addr{}
			}
			if err := m.RelayToAddr.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RelayFromAddr", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNebula
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNebula
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNebula
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RelayFromAddr == nil {
				m.RelayFromAddr = &Addr{}
			}
			if err := m.RelayFromAddr.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNebula(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthNebula
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipNebula(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowNebula
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowNebula
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowNebula
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthNebula
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupNebula
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthNebula
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthNebula        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowNebula          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupNebula = fmt.Errorf("proto: unexpected end of group")
)
